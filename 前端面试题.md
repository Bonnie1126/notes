# 第一章 面试题基础篇

## 		1.1 HTML面试题				

### 				**1. 行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？**

```
行内元素：span、img、input select...
块级元素：div、footer、header、section、p、h1...h6...
空元素：br、hr...


元素之间的转换问题：
display: inline;  			把某元素转换成了行内元素      ===>不独占一行的，并且不能设置宽高,可以设置水平方向的margin padding不可以设置垂直方向的margin padding
display: inline-block; 	把某元素转换成了行内块元素		 ===>不独占一行的，可以设置宽高和内外边距
display: block;					把某元素转换成了块元素			   ===>独占一行，并且可以设置宽高和内外边距
```

### 				**2. 页面导入样式时，使用link和@import有什么区别？**

```
功能的区别: link是html标签,除了加载css外,还可以加载其他资源,@import只能加载css
加载顺序的区别: link引入css样式时,在页面的加载的同时加载;@import需要页面完全载入以后再加载,所以是先加载link再加载@import
兼容性:link是html标签,没有兼容性问题;@import是css2之后提出的,低版本浏览器不支持
DOM操作的区别: link支持js控制dom去改变样式,而@import不支持
```

### 				**3. title与h1的区别、b与strong的区别、i与em的区别？**

```
title与h1的区别：

定义：
	title：是网站的标题，可以告诉搜索引擎或者用户关于这个网站的内容主题是什么,京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！
	h1：是该页面的主题内容,告诉爬虫这个页面主要是讲什么的,网站的logo 文章的大标题都是用h1标签包裹的	
区别：
	title他是显示在网页标题上、h1是显示在网页内容上
	对于seo来说,title比h1添加的重要 (title > h1 ) 
	
```

```
b与strong的区别：
都是可以加粗的
区别：
	b标签只有加粗的样式，没有实际含义。
	strong 语义化标签，用来加强字符语气的,表示标签内字符比较重要，用以强调的。
题外话：为了符合css3的规范，b尽量少用该用strong就行了。
```

```
i与em的区别：

定义：
	i:实体标签，用来做文字倾斜的。
	em：是语义化标签，用来强调文字内容的
区别：
	i只是一个倾斜标签，可以让文字倾斜,没有实际含义。
	em表示标签内字符重要，用以强调的。
场景：
	i更多的用在字体图标，em术语上（医药，生物）。
```

### 				**4. img标签的title和alt有什么区别？**

```
区别一：
	title ： 鼠标移入到图片显示的值
	alt   ： 图片无法加载时显示的值
区别二：
	在seo的层面上，爬虫抓取不到图片的内容，所以前端在写img标签的时候为了增加seo效果要加入alt属性来描述这张图是什么内容或者关键词。
```

### 				**5. png、jpg、gif 这些图片格式解释一下，分别什么时候用？**

```
png:无损压缩，尺寸体积要比jpg/jpeg的大，适合做小图标。
jpg:采用压缩算法，有一点失真，比png体积要小，适合做中大图片。
gif:一般是做动图的。
webp：为web而生的图片格式,同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好。
```

### 6.  src和herf的区别

```
src: 表示对资源的引用,它指向的内容会嵌入到当前标签所在的位置,如果img audio video,
		 src会将其指向的资源下载并应用到文档,比如js脚本
		 当浏览器解析到该元素时,会暂停其他资源的下载和处理,直到当前的资源加载 编译 执行完毕,所以js脚本一般会放在最后引入
href: 表示超文本引用,它指向一些网络资源,建立和当前元素或文档的链接关系
			当浏览器识别到它指向的文件时,就会并行下载资源,不会停止对当前文档的处理 
			常用在 a link 标签上
```

### 7. 对HTML语义化的理解

```
语义化是指根据内容的结构，选择合适的标签，通俗来讲就是用正确的标签做正确的事
语义化的优点：
1. 对机器友好，带有语义标签的文字表现力更加丰富，更适合搜索引擎的爬虫提取有效信息，有利于seo。也支持读屏软件，根据文章可以自动生成目录
2. 对开发者友好，增强可读性，结构更加清晰，开发者能清晰的看出网页结构，便于团队的开发与维护
常见的语义化标签：
header nav section main article aside footer

```

### 8. script 标签中的 defer 和 async 的区别

```
如果没有 defer 和 async 属性，浏览器会立即加载并执行响应的脚本，它不会等待后续加载的元素文档，读取到就会开始加载和执行，这样就阻塞了后续文档的加载
defer 和 async 都是去异步加载外部 js 文件的，他们不会阻塞页面的解析
执行顺序的区别：多个带 defer 属性的标签，按照加载顺序执行；多个带 async 属性的标签，不能保证加载的顺序。
脚本是否并行执行：defer 属性，加载后续文档和加载 js 脚本是并行进行的，js 脚本需要等所有元素解析完毕之后才执行，DOMContentLoaded 事件触发之前执行。
							async 属性，加载后续文档和加载 js 脚本及执行 js 脚本是并行的
```

### 9.h5 有哪些更新

#### 9.1 语义化标签

header footer nav section aside

#### 9.2 媒体标签

audio 音频 video 视频

#### 9.3 表单

- 表单类型

  email、url、number、search、color、time、date、week、month

- 表单属性

  placeholder、autofocus 自动获取焦点、autocomplete=“on”表单提交过的话会自动填充、required、pattern 正则

- 表单事件

  oninput 每当 input 中内容发生变化则会触发

  oninvaild 当验证不通过时触发

#### 9.4 进度条度量器

progress 标签

#### 9.5 DOM 查询

document.querySelector()

document.querySelectorAll（）返回指定元素对象的集合，伪数组形式

选择的对象可以是标签、类名、id

#### 9.6 web 存储

提供了两种在客户端存储数据的新方法：

localStorage：没有时间限制的数据存储

sessionStorage：针对一个 session 的数据存储 

#### 9.7 拖放

<img draggable = "true">  可以拖放

#### 9.8 画布

canvas 标签,使用 js 在网页上绘制图像

#### 9.9 SVG

可伸缩矢量图形

#### 9.10 history API

go、back、forward

#### 9.11 websocket 通信协议





## 1.2 CSS面试题

### 				1. 介绍一下CSS的盒子模型

```
CSS的盒子模型有哪些：标准盒子模型、IE盒子模型
CSS的盒子模型区别：
	标准盒子模型：margin、border、padding、content，设置的 width 是 content 的宽度，padding 和 border 会撑大盒子
	IE盒子模型 ：margin、content（ border +  padding  + content ）padding和border就不会撑大盒子，会向内延伸（前提是padding和border不会超过width），如果超过了，width=border+padding
通过CSS如何转换盒子模型：
	box-sizing: content-box;	/*标准盒子模型*/
	box-sizing: border-box;	  /*IE盒子模型*/
```

### 2. line-height和heigh区别【大厂】

```
line-height 和 height 都能撑开一个高度
line-height 是元素中每一行文字的高度，包含了文字的尺寸和上下间距
而 height 是元素的高度
如果一个标签没有定义height 属性，那么其最终表现的高度由 line-height 决定，如果文字换行则整个盒子高度会增大（行数*行高）

line-height 的赋值方法：
1. px 固定值
2. 纯数字，或百分比 会把比例传递给后代，子元素的行高为 父级行高*子元素字体的尺寸 如：1.5*18px


```

### 3.CSS选择符有哪些？哪些属性可以继承？

```
CSS选择符：
    通配（*）
    id选择器（#）
    类选择器（.）
    标签选择器（div、p、h1...）
    相邻选择器(+)选择下一个兄弟   排除掉第一个 ul li + li{ } 
    后代选择器(ul li)
    子元素选择器（ > ）
    属性选择器(a[href])
    伪类选择器（E：first-child）
    伪元素选择器（E::before） 在这个元素前面添加一个标签
    
```

### 4. 哪些属性可以继承

```
字体系列：
	font-size
	font-family
	font-weight
	font-style
文本系列：
	text-align：文本水平对齐方式
	text-indent：文本缩进
	line-height
	word-sapcing：单词之间的距离
	color：文本颜色
元素可见性：
	visibility：
列表布局属性
	list-style
光标属性
	cursor
```

哪些属性不可以继承

```
display
文本属性：
	vertical-align：文本的垂直对齐方式
	text-decoration：文本装饰 下划线、删除线 
盒子模型的属性：
	width、height、margin、border、padding
背景属性：
	background 相关
定位属性：
	定位相关
轮廓样式

```

### 5. CSS优先级算法如何计算？

```
优先级比较：!important > 内联样式 > id > class > 标签 > 通配
```

```
CSS权重计算：
第一：内联样式（style）                  权重值:1000
第二：id选择器  				                权重值:100
第三：类选择器、伪类选择器、属性选择器      权重值:10
第四：标签、伪元素选择器                   权重值:1
第五：通配、后代选择器、>子选择器、+相邻选择器         权重值:0
```

​	需要注意：多个选择器写在一起权重会叠加

​						如果优先级相同，以最后出现的为准

​						继承得到的优先级最低



### 6. 用CSS画一个三角形

border 其实是由三角形组成，上右下左都是三角形

```
用边框画（border）,例如：
{
		width: 0;//宽高都设置为 0
		height: 0;

		border-left:100px solid transparent;//三角形对面那个可以不写
		border-right:100px solid transparent;
		border-top:100px solid transparent;
		border-bottom:100px solid #ccc;//如果要底部的三角形，只给底部的三角形设置颜色,其他都设置成透明
		//如果要画扇形 加一个 border-radius ： 50%
		border-radius：50%
}
```

### 7. 一个盒子不给宽度和高度如何水平垂直居中？

 方式一：

给父盒子设置 flex 布局，justify-content 和 align-items 都设置成 center 

```
<div class='container'>
	<div class='main'>main</div>
</div>

.container{
		display: flex;
		justify-content: center;//主轴方向的排列方式
		align-items: center;//侧轴方向的排列方式(单行)
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		background: red;
}
```

方式二：

通过定位,子绝父相,left 和 top 都给 50%,transform：translate（-50%，-50%）

```
<div class='container'>
	<div class='main'>main</div>
</div>

.container{
		position: relative;
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		position: absolute;
		left:50%;
		top:50%;
		background: red;
		transform: translate(-50%,-50%);
}
```

### 8. display有哪些值？说明他们的作用。

```
none     			隐藏元素
block    			把某某元素转换成块元素，独占一行，可以设置宽高和内外边距
inline   			把某某元素转换成内联元素，不会独占一行，不可以设置宽高，只能设置水平 padding margin 不可以设置垂直
inline-block 	把某某元素转换成行内块元素，不会独占一行，但可以设置宽高以及内外边距
```

### 9. 对BFC规范(块级格式化上下文：block formatting context)的理解？

```
BFC就是页面上一个隔离的独立容器，是布局过程中生成块级盒子的区域,也是浮动元素与其他元素的交互限定区域,容器里面的子元素无论怎么摆放,不会影响到外面的元素。

1. 了解BFC ： 块级格式化上下文。
2. BFC的原则：如果一个元素具有BFC，那么内部元素再怎么摆放，都不会影响到外面的元素。
3. 如何触发BFC：在父盒子上设置 body 也是一个 BFC
		方式一：float的值非none，而是 left 或 right
		方式二：overflow的值非visible，而是 hidden、auto、scroll
		方式三：display的值为：inline-block、table...
		方式四：position的值为:absoute、fixed
4. BFC 的特点:
(1)在 BFC 中上下相邻的两个容器的 margin 会重叠
(2)计算 BFC 高度时,根据浮动元素的高度来定
(3)BFC 区域不会与浮动的容器发生重叠
(4)BFC 是独立的容器,容器内部元素不会影响外部元素
(5)每个元素的左 margin 值和容器的左 border 值相接触

5. 应用:
(1)解决 margin 重叠问题
两个块级元素的上外边距和下外边距可能会合并为一个外边距,其大小会取外边距中较大的那个值.需要注意的是,浮动元素或绝对定位这种脱离标准流的元素不会发生 margin 重叠问题,margin 重叠只会发生在垂直方向上
解决方法:由于 BFC是一个独立的区域,内部元素和外部元素互不影响,将两个元素其中一个变为 BFC,就解决了 margin 重叠的问题
兄弟之间发生 margin 合并,
		底部盒子变为行内块盒子 display:inline-block;
		底部元素设置浮动:float
		底部元素设置绝对定位 或 固定定位
父子之间发生 margin 合并,
		父元素加入:overflow:hidden;
		父元素添加边框
		子元素变成行内盒子:display:inline-block
		子元素加入浮动或绝对定位

（2）解决高度塌陷的问题
在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度为 0了
解决方法：把父元素变成一个 BFC，常用的办法是给父元素设置 overflow：hidden

（3）创建自适应两栏布局：左边宽度固定，右边宽度自适应
方法：左边设置 float：left；右边不给宽度，设置 overflow：hidden；这样右边就触发了 BFC，BFC 区域不会与浮动元素发生重叠，所以两侧不会发生重叠，实现了自适应两栏布局


```

### 10. 清除浮动有哪些方式？

```
浮动的工作原理：
浮动元素脱离文档标准流，不占据空间（所以会引起高度塌陷问题），从而影响后面的布局
浮动元素碰到包含它的边框，或者其他浮动元素的边框停留

清除浮动的方式：
1. 父盒子变成一个 BFC overflow：hidden
2. 多创建一个盒子，添加样式：clear: both;
3. after伪元素方式，添加了一个行内块元素
	ul:after{
			content: '';
			display: block;
			clear: both;//clear 的含义是元素的边不能和前面的浮动元素相邻
	}
4. 给父盒子定义height
```

### 11. 在网页中的应该使用奇数还是偶数的字体？为什么呢？

```
偶数 : 让文字在浏览器上表现更好看。

另外说明：ui给前端一般设计图都是偶数的，这样不管是布局也好，转换px也好，方便一点。
```

### 12. position有哪些值？分别是根据什么定位的？

```
static [默认]  没有定位，比如用 ui 框架时有定位，我不想要定位，就用这个值进行覆盖
fixed  固定定位，相对于浏览器可视窗口（不是文档）进行定位，滚动条怎么滚，还是这个位置。
relative  相对于自身定位，不脱离文档流，移动了还占有原来的位置
absolute	相对于第一个有定位的父元素，脱离文档流，移动后则不占有原来的位置。


relative和absolute区别
1. relative不脱离文档流 、absolute脱离文档流
2. relative相对于自身 、 absolute相对于第一个有relative的父元素
3. relative如果有left、right、top、bottom 最终只呈现 left、top
	 absolute如果有left、right、top、bottom 最终呈现 left、right、top、bottom
```

### 13.两栏布局

左边一栏宽度固定，右边一栏宽度自适应

方法一：利用浮动，左边设置宽度，float：left；右边 margin-left 200px，宽度设置为 auto（撑满整个父元素）

```
.container {
            height: 200px;
        }
.l {
            float: left;
            width: 200px;
            height: 100%;
            background-color: red;
        }
        
.r {
            width: auto;
            height: 100%;
            margin-left: 200px;
            background-color: blue;
        }
```

方法二：利用浮动，左边设置宽度，float：left；右边overflow：hidden 触发 BFC，BFC 区域不会与浮动元素发生重叠

```
.container {
            height: 200px;
        }
.l {
            float: left;
            width: 200px;
            height: 100%;
            background-color: red;
        }
        
.r {
            height: 100%;
            background-color: blue;
            overflow：hidden
        }
```

方法三：利用 flex 布局，左边给固定宽度，右边 flex：1

```
.container {
            display: flex;
            height: 200px;
        }
        
        .l {
            width: 200px;
            background-color: red;
        }
        
        .r {
            flex: 1;// flex-grow：1 ； flex-shrink：1；flex-basis：0%
            background-color: blue;
        }
```

方法四：利用绝对定位，父元素设置成相对定位，左边元素绝对定位，给个宽度，右边margin-left 那个宽度；

```
.container {
            position: relative;
            height: 200px;
        }
        
        .l {
            position: absolute;
            width: 200px;
            height: 100%;
            background-color: red;
        }
        
        .r {
            margin-left: 200px;
            height: 100%;
            background-color: blue;}
```

方法五:利用绝对定位,两个子盒子都是相对定位,左边给个宽度,右边 left200px

```
.container {
            position: relative;
            height: 200px;
        }
        
        .l {
            position: absolute;
            width: 200px;
            height: 100%;
            background-color: red;
        }
        
        .r {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 200px;
            height: 100%;
            background-color: blue;}
```

### 14. 三栏布局

左右两栏宽度固定，中间自适应

方式一：利用绝对定位，父盒子相对定位，两边的盒子各自方向绝对定位，中间的盒子设置对应方向的 margin 值

```
.container {
            position: relative;
            height: 200px;
        }
        
        .l {
            position: absolute;
            left: 0;
            top: 0;
            width: 200px;
            height: 100%;
            background-color: red;
        }
        
        .r {
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 100%;
            background-color: blue;
        }
        
        .c {
            height: 100%;
            margin-left: 200px;
            margin-right: 200px;
            background-color: pink;
        }
```

方式二：

利用 flex布局，左右两栏设置固定大小，中间 flex：1

```
.container {
            display: flex;
            height: 200px;
        }
        
        .l {
            width: 200px;
            height: 100%;
            background-color: red;
        }
        
        .r {
            width: 200px;
            height: 100%;
            background-color: blue;
        }
        
        .c {
            flex: 1;
            height: 100%;
            background-color: pink;
        }
```

方式三：

利用浮动，左右设置固定大小，并设置相应位置的浮动。中间设置左右两个方向的 margin 值，注意这种方式中间一行必须放在最后

```
.container {
            height: 200px;
        }
        
        .l {
            float: left;
            width: 200px;
            height: 100%;
            background-color: red;
        }
        
        .r {
            float: right;
            width: 200px;
            height: 100%;
            background-color: blue;
        }
        
        .c {
            margin-left: 200px;
            margin-right: 200px;
            height: 100%;
            background-color: pink;
        }
```

### 15. 圣杯布局

在CSS中，圣杯布局是指两边盒子宽度固定，中间盒子自适应的三栏布局，其中，中间栏放到文档流前面，保证先行渲染

利用浮动和负边距来实现。父级元素设置左右的 padding，三列均向左浮动，中间一列放在最前面，宽度设置为父级的宽度，因此后面的两列都挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边

```
.container {
            height: 200px;
            padding-left: 100px;
            padding-right: 200px;
        }
        
        .l {
            position: relative;
            left: -100px;

            float: left;
            margin-left: -100%;

            width: 100px;
            height: 100%;
            background-color: red;
        }
        
        .r {
            position: relative;
            left: 200px;

            float: left;
            margin-left: -200px;
						
            width: 200px;
            height: 100%;
            background-color: blue;
        }
        
        .c {
            float: left;
            width: 100%;
            height: 100%;
            background-color: pink;
        }
```

### 16.  双飞翼布局

相对于圣杯布局来说，左右位置的保留是通过中间列里面再放一个div，的 margin 值，而不是父盒子的 padding 来实现的，本质上来说，也是通过浮动和外边距来实现的

```
.container {
            width: 100vw;
            height: 100vh;
        }
        
        .container>div {
            float: left;
        }
        
        .l {
            margin-left: -100%;
            height: 100vh;
            background-color: red;
            width: 200px;
        }
        
        .r {
            margin-left: -200px;
            height: 100vh;
            background-color: blue;
            width: 200px;
        }
        
        .wraper {
            width: 100%;
            height: 100vh;
            background-color: pink;
        }
        
        .c {
            margin-left: 200px;
            margin-right: 200px;
            height: 100%;
            background-color: green;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="wraper">
            <div class="c"></div>
        </div>
        <div class="l">左</div>
        <div class="r">右</div>
    </div>
</body>
```

### 17. 什么是CSS reset？

```
reset.css   		是一个css文件，用来重置css样式的。
normalize.css 	是 bootstrap 提供的一个，为了增强跨浏览器渲染的一致性，一个CSS 重置样式库。
```

### 18. css sprite是什么,有什么优缺点

```
1. 是什么
	雪碧图，把多个小图标合并成一张大图片。
2. 优缺点
	优点：减少了浏览器对服务器的请求的次数，提升了性能。
	缺点：维护比较差（例如图片位置进行修改或者内容宽高修改）
```

### 19. display: none;与visibility: hidden;的区别

```
1. 占用位置的区别
display: none; 				是不占用位置的，只在 dom 树中存在，不在 render 树中存在
visibility: hidden;   虽然隐藏了，但是占用位置，在渲染数中存在

2. 重绘和回流的问题

visibility: hidden 产生重绘
display: none;     产生重绘 还会产生一次回流 因为第一次并没有将 dom 和 css 合并到 render tree 中

产生回流一定会造成重绘，但是重绘不一定会造成回流。

产生回流的情况：改变元素的位置(left、top...)、宽高，display：none，影响父元素或者更早的元素
产生重绘的情况：样式改变（background color）

关于重绘和回流：https://blog.csdn.net/fagdg/article/details/123676938

3. 是否继承
display：none 是非继承属性，子节点会随着父节点从渲染数中一起消失，通过设置子节点的属性也无法将子节点显示出来
visibility：hidden 是继承属性，子节点消失是由于继承了父节点的 hidden，通过设置子节点的 visibility：visible 是可以显示子节点的

```

### 20. 隐藏元素的方法

```
1. display：none：只在 dom 树中存在，不在 render 树中存在，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件
2. visibility：hidden 元素在页面中仍占据位置，但不会响应绑定的监听事件
3. transform：scale（0,0）将元素缩放为 0，来实现元素的隐藏，占位置，不可响应监听事件
4. position：absolute 通过绝对定位将元素移出可视区域外
5. z-index：通过其他元素的遮盖来实现隐藏
6. opacity：0；将元素的透明度设置为 0，来实现元素的隐藏，在页面占有位置，能够响应元素绑定的监听事件

```



### 21. opacity 和 rgba区别

```
共同性：实现透明效果

1. opacity 取值范围0到1之间，0表示完全透明，1表示不透明
2. rgba   R表示红色，G表示绿色，B表示蓝色，取值可以在正整数或者百分数。A表示透明度取值0到1之间

区别：继承的区别
opacity会继承父元素的opacity属性，而RGBA设置的元素的后代元素不会继承不透明属性。
比如子盒子里面有文字，父盒子里面是背景颜色，那么 opacity 会给背景颜色和文字都设透明度，而 rgba 只给父盒子设置透明度，子元素不会继承，文字没有透明度
```

### 22. 伪元素和伪类的区别

```
：：伪元素：在内容元素的前后插入额外的元素，但这些元素并不会在文档中生成，他们只在外部显示可见，不会在源代码中找到他们，因此也称为伪元素，比如 div：：after{}在 div 的最后插一个行内块，设置一些内容和样式
：伪类：将特殊的效果添加到特定的选择器上，它是在已有元素上面加类别，不会产生新的元素
例如：p：hover{ color:blue}
p:first-child{}
```

### 23. 为什么有时候用 translate 改变位置而不是定位

```
translate 是 transform 属性的一个值，改变 transform 不会触发浏览器的回流、重绘；
但是改变绝对定位会让浏览器重新布局，就会产生回流、重绘。
所以 translate 改变位置会更高效一些。但是 translate 改变位置时，仍会占用其原始空间，绝对定位则不会
```

### 	24. DOM 的加载过程

```
1.在浏览器中输入URL,交给DNS域名解析，找到IP，向服务器发送请求；（里面还有缓存，http协议，TCP等等）

2.服务器返回数据，浏览器接收文件（html,js,css,img...）,二进制文件。

    二进制转换成html，比如index.html

     构建DOM树，html解析器，过程中遇到没有defer和async的<script>时，会中断解析，等待<script>下载完成继续开始解析。

        文件解析的过程中遇到含有defer和async的<script>时，会放到后台进行下载，并不会阻止当前文件的解析。（defer是整个页面解析完毕后才开始执行。async是异步执行，页面未必解析完毕）

 3.构建css树，css解析器

4.构建render树，dom树+css树

5.布局layout与绘制point,计算对象之间的大小，确定每个节点在屏幕的确切坐标。

reflow（回流）：当元素属性发生改变且影响布局时（宽高、内外边距等），产生回流，会进行重新布局，相当于刷新页面

repaint（重绘）：当元素属性发生改变且不影响布局时（颜色、透明度等），产生重绘，相当于不刷新页面，动态更新内容。

重绘不一定引起回流，回流必将引起重绘

```

### 25.CSS3 有哪些新特性

```
1. 新增了一些选择器，如    ：not（.input）选中所有类名不是 input 的元素
2. 圆角 border-radius
3. 文字阴影 text-shadow
4. 文字装饰 text-decoration
5. 线性渐变 gradient
6. 滤镜 filter：blur（0.5）模糊函数；
7. calc（100%-80px）对宽度进行计算
8. 2d 转换 3d 转换 transform
9. 过渡动画 transition 动画 animation
10.浏览器私有前缀
11.flex 布局
```

### 26.什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时，需要用到二倍图三倍图

```
物理像素是屏幕显示的最小颗粒，是物理真实存在的，也就是设备的真实像素
逻辑像素就是开发时使用的px，pc端页面1个px等于1个物理像素，但是移动端就不尽相同
1个开发时的px能显示的物理像素点的个数，称为物理像素比或像素密度 1CSSpx=n个物理像素

比如 iphone xs 为例，当写 css 的时候，针对于单位px，其宽度为 404px*896px，也就是说当赋予一个div 元素宽度为 404px，就会占满手机屏幕的宽度。
而实际这个手机的物理像素，是 1212*2688，1212/404=3,也就是说在单边上，一个逻辑像素=3 个物理像素，屏幕的像素密度就是 3，也就是常说的 3 倍屏。
对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，加入原始图片是 100 像素，那么在三倍屏上就要放一个 300 像素的图片才能不失真    
```

### 27. 对媒体查询的理解

```
使用媒体查询，可以针对不同的媒体类型定义不同的样式
@media 可以针对不同屏幕尺寸设置不同的样式
当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面

媒体查询由一个可选的媒体类型和（0 个或多个媒体特性）组成，最终会被解析为 true 或 false，如果媒体查询匹配到响应的设备尺寸，并且所有表达式都为 true，那么媒体查询内的样式将会生效。实现不同设备类型和尺寸的自适应的效果
```



### 28.css布局单位

```
1. 像素（px）是页面布局的基础单位，一个像素表示屏幕能显示的最小区域，而且 px 是固定的像素，一旦设置了无法因为适应页面大小而变化。像素区分为两种类型
   逻辑像素，为 web 开发使用，是一个抽象单位
   物理像素，硬件设备的真实像素，它们之间的比值是像素密度
2. 百分比：当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽度和高度随着浏览器的变化而变化，从而实现响应式的效果，一般情况下，子元素的百分比相对于直接的父元素
3. em 和 rem，相对于 px 更具有灵活性，他们是相对长度单位，是不固定的，更适用于响应式布局
	em：相对于父元素字体大小来定义
	rem：相对于根元素 html 元素的字体大小来定义
4. vw视口宽度，vh 视口高度
```

### 29.如何根据设计稿进行移动端适配

```
移动端适配主要有两个维度：
适配不同的像素密度：也就是几倍屏，针对不同的像素密度，使用 css 媒体查询，选择不同精度的图片，以保证图片不会失真
适配不同的屏幕大小：自适应的方法：淘宝无限适配+rem 由于不同屏幕有不同的逻辑像素大小，如果直接用 px 作为开发单位，会使得开发的页面在某一款手机上可以精确显示，但在另一款手机上就会失真。为了适配不同的屏幕大小，应该按照比例来还原设计稿的内容。为了让页面尺寸可以自适应，可以使用 rem em vw vh 等相对单位
```

### 31. display float position 的关系

```
首先判断 display 是否为 none，如果是，则 position和 float 都不起作用
position 是 absolute 或者 fixed，则浮动不起作用，并且 display 被设置成块级
position 是 relative 并且 float 存在，则 relative 相对于浮动后的最终位置定位
如果 float 不为 none，或者是根元素，则 display 被设置成块级
最后，非根元素，非浮动元素，非定位元素，display 的值同设置的值
```

### 32. 解决 1px 问题

```
1px 问题是指在一些视网膜屏机型上，移动端的 1px 会变得很粗，因为 css 中的 1px 并不能和手机屏幕的 1px 划等号，他们之间存在一个比值，像素密度，也就是 window.devicePixelRatio，这个值是几就表示移动端设备上用几个像素来渲染 1 个 css 的 px，所以实际看到会比 1px 粗一些
解决方法：
拿到 window.devicePixelRatio,给到要改变的元素上的自定义属性，通过属性选择器来选出该元素，1px 改成 1/devicePixelRatio 的值
解法 2：伪元素先放大后缩小；在目标元素后面放一个伪元素，让这个元素 absolute 定位之后，宽高设为 2 倍，border 设为 1px，再把伪元素缩小为原来的 50%，伪元素刚好和目标元素对齐，border也缩小到原来的 1/2,间接实现了开发时 0.5px，实际展示出 1px 的效果3
```

### 33.flex 布局

```
css3 新增的弹性布局，用来为盒子的布局提供很大的灵活性，display：flex；采用 flex 布局的元素称为 flex 容器，它的所有子元素自动称为容器成员，称为 flex 项目。容器默认存在两根轴，主轴和侧轴，默认水平轴为主轴。设置了 flex 布局的容器，子元素 float、clear、vertical-align 属性都会失效
容器包括以下属性：
	flex-direction：决定主轴的方向
	flex-warp：是否要换行
	justify-content 项目在主轴上的对齐方式
	align-items 单行项目在侧轴上的对齐方式
	align-content 多行项目在侧轴上的对齐方式
项目包括一下属性：
	order：排列顺序，数越小越靠前
	flex-grow：定义项目的放大比例，如果有剩余空间，这个子项目会被分到几份
	flex-shrink：定义项目的缩小比例，如果空间不足，这个子项目会缩小几份
	flex-basis：分配多余空间之前，该项目占多少主轴的空间
	flex：1 表示 grow：1 shrink：1 basis 0%
	align-self：表示可以和其他项目有不一样的对齐方式，可覆盖 align-items 的值
```



## 1.3 JavaScript基础面试题

### 1.延迟加载JS有哪些方式？

```
如果没有 defer 和 async 属性，浏览器会立即加载并执行响应的脚本，它不会等待后续加载的元素文档，读取到就会开始加载和执行，这样就阻塞了后续文档的加载
defer 和 async 都是去异步加载外部 js 文件的，他们不会阻塞页面的解析

执行顺序的区别：多个带 defer 属性的标签，按照顺序执行的；多个带 async 属性的标签，不能保证执行的顺序（谁先加载完谁先执行）。

脚本是否并行执行：defer 属性，解析 html和加载 js 脚本是并行进行的，js 脚本需要等所有元素解析完毕之后才执行，DOMContentLoaded 事件触发之前执行。
							async 属性，解析 html和加载 js 脚本是并行的，加载完就执行

```

### 2.JS数据类型有哪些？

```
八大数据类型
（1）基本类型：string字符串、number数值类型、boolean布尔值、undefined、null、
symbol（创建后独一无二不可变，为了解决可能出现的全局变量冲突问题）、bigint（可以表示任意精度的整数，用来安全的存储和操作大整数）
（2）引用类型：object

NaN是一个number，但是不是一个具体的数字。

两种数据类型存放的位置不一样
· 基本数据类型直接存储在栈中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据，所以放在栈中。
· 引用数据类型存放在堆中，占据空间大，大小不固定，如果存储在栈中的话，将会影响程序运行时的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用类型的值时，会首先检索其在栈中的地址，取得地址后再到堆中获得实体
```

### 3.JS数据类型考题	

#### 考题一：隐式转换

字符串和其他类型相加，都会变成字符串

```
console.log( true + 1 );     			//2 true 转换成 1
console.log( 'name'+true );  			//nametrue 字符串和任何相加都会变成字符串
console.log( undefined + 1 ); 		//NaN 不是数字
console.log(typeof null);         //Object
console.log( typeof undefined ); //undefined
```

#### 考题二：

```  
console.log( typeof(NaN) );       //number
console.log( typeof(null) );      //object
```

### 4.null和undefined的区别

```
作者在设计js的都是先设计的null（为什么设计了null：最初设计js的时候借鉴了java的语言,是一个空对象）；并且 js 初期是没有错误处理机制的，发生数据类型不匹配的时候，会默默转换类型或者默默失败，作者觉得null会被隐式转换成0，很不容易发现错误。
于是又设计了 undefined，出来undefined是为了填补之前的坑。表示一个无的原始值，最好不要是对象，并且运算时不要自动转换成 0

具体区别：null是一个表示"无"的对象（空对象指针），转为数值时为0；undefined是一个表示无的原始值，转为数值时为NaN。
一般变量声明了但是没有赋值就会返回 undefined，null 主要用于赋值给一些可能返回对象的变量，作为初始值
```

### 5.数据类型检测方法有哪些

```
1. typeof
	typeof 2  //number
	但数组是 Object
2. instanceof
	[] instanceof Array // true
注意 instanceof 只能判断引用数据类型，其原理是测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，如[]这个对象的原型链中是否有 Array.prototype

3. constructor
('str').constructor === String //true
constructor 主要有两个作用，一是判断数据类型，二是对象实例通过 constructor来访问它的构造函数，如果创建一个对象来改变它的原型 如Fn.prototype = new Array()，那么constructor 就不能用来判断数据类型了

4. Object.prototype.toString.call()
为什么 obj.toString()的结果和Object.prototype.toString.call()的不一样？
Array、function 等类型作为 Object 的实例，都重写了 toString 方法，不同的对象类型调用 toString的时候，根据原型链的知识，调用的是对应重写的 toString 方法，返回的是字符串；而不会去调用 Object 原型上的 toString 方法，这个方法才是返回对象的具体类型。所以采用 obj。toString（）不能得到其对象类型，只能将 obj 转成字符串；因此，在想要得到对象的具体类型，应该调用 Object 原型上的 toString 方法
```

### JS判断变量是不是数组，你能写出哪些方法？



#### 方式一：Array.isArray

```
var arr = [1,2,3];
console.log( Array.isArray( arr ) );
```

#### 方式二：instanceof  【可写,可不写】

```
var arr = [1,2,3];
console.log( arr instanceof Array );
```

#### 方式三：通过Object.prototype.toString.call()

```
var arr = [1,2,3];
console.log( Object.prototype.toString.call(arr).indexOf('Array') ！= -1 ); //call完了是个字符串
```

#### 方式四：Array.prototype.isPrototypeOf(arr)

```
var arr = [1,2,3];
console.log(  Array.prototype.isPrototypeOf(arr) )
```

#### 方式五：constructor

```
var arr = [1,2,3];
console.log(  arr.constructor.toString().indexOf('Array') != -1 )
```

#### 方式六：原型链

```
arr.__proto__ == Array.prototype
```



### 双等号和三等号有什么不同？以及Object.is()

```
==  :  比较的是值,如果两边类型不一样的话，会进行强制类型转换再比较
		强制转换规则：
		（1）如果是 null 和 undefined 比较，直接返回 true
		（2）string||boolean 和 number 会转换成 number
		（3）Object 会转成基本类型
		通过Object.prototype.valueOf转换（valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。）

=== ： 除了比较值，还比较类型
```

### 为什么 0.1+0.2=！0.3，如何让其相等

```
让其相等的方式
（0.1+0.2）.toFixed(1) //toFixed会将 Number 四舍五入为指定小数位数的数字

为什么？
计算机是通过二进制的方式存储数据的，所以计算机计算 0.1+0.2 的时候，实际上式计算两个数的二进制的和。0.1 和 0.2 转换成二进制都是无限循环的小数。JS 中的 NUmber 数字类型，使用 64 位固定长度来表示，也就是标准的双精度浮点数。在二进制的科学表示法中，双精度浮点小数部分最多只能保留52 位，再加上前面的1，其实就是保留 53 位有效数字，剩余的都要舍去，遵循 0 舍1 入的原则，这样就造成了精度丢失。所以根据这个原则，0.1和0.2的二进制数相加，再转换为十进制是 0.3000000004，并不等于 0.3 
```



### instanceof 操作符的实现原理????

```
instanceof 运算符是用来判断构造函数的 prototype 是否出现在对象的原型链中的任何位置

function myInstanceOf (left,right){
	//获取对象的原型
	let proto = Object.getPrototypeOf(left)
	//获取构造函数的 prototype
	let prototype = right.prototype
	//判断构造函数的 prototype 是否在对象的原型链上
	while(true){
		//如果没有找到，就继续从其原型上找 Object.getPrototypeOf()方法用来获取指定对象的原型
		proto = Object.getPrototypeOf(proto)
	
	}
	
}
```

### JS微任务和宏任务

```
JS 的执行机制：js是单线程的语言，为了能异步处理一些事务，将代码分成了同步任务和异步任务
1. 主线程读取JS代码,执行同步任务
2. 异步任务,会推给异步进程(Web API 也是宿主)进行处理
3. 已完成的异步任务,其回调函数被推入任务队列(任务队列又分宏任务和微任务)
4. 同步任务结束后，主线程查询任务队列,执行微任务,将其按顺序推入主线程执行,全部执行完毕
5. 主线程查询任务队列,执行宏任务,将其按顺序执行,每执行完一个宏任务都要判断一下是否还有微任务，有则推入主线程执行，
6. 重复以上的4. 5步(主线程重复从消息队列中取消息、执行的过程就是事件循环:事件循环包含宏微任务)

微任务：promise.then .catch  .finally   process.nextTick 注意 new Promise（）{}是同步任务
宏任务：ajax 请求、定时器、点击。。。

要执行宏任务的前提是清空了所有的微任务


```



### 原型、原型链

```
1. 原型：在 js 中是使用构造函数来新建一个对象的，每个构造函数内部都有一个 prototype 属性，他的属性值是一个对象。
这个对象包含了可以由该构造函数的所有实例对象共享的属性和方法 ， prototype 又包含一个 constructor 指向构造函数。
当使用构造函数创建一个对象后，在这个对象内部将包含一个__proto__指向构造函数的 prototype。也可以用Object.getPrototypeOf(obj)的方法来获取对象的原型

2. 原型链：
当访问一个对象的属性或方法的时候，顺序是
	先在对象本身查找 obj.run
  构造函数中查找  fun{this.run}
  构造函数的原型中(对象的原型__proto__指向它)  fun.prototype.run
  构造函数的原型的原型中查找 fun.prototype.__proto__ ，因为构造函数也是由上一层的构造函数生成的，所有函数都是由 Function 生成的，上一层的构造函数也有自己的原型
  那么把原型都链接起来，就是原型链，原型链的最后一个原型是 Object.prototype，再后面就是 null 了，所以这也是新建的对象为什么能够使用 Object.prototype中的方法的原因
  
特点：JS 对象是通过引用来传递的，创建的实例对象中并没有属于自己的一份原型副本，所以当修改原型时，与之相关的对象也会继承这一改变
```



### 闭包⭐️⭐️⭐️

```
1. 闭包是什么：
闭包是指有权访问另一个函数作用域的函数，创建闭包的最常见的方法就是在当前函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量，并且当前函数的变量不会在该函数执行完就回收

2. 闭包的用途
（1）内部函数可以访问到外部函数的局部变量
（2）使已经运行结束的函数上下文中的变量继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收
比如页面上有 4 个 li，我给每个 li 用 for 循环来绑定点击事件，事件的处理函数就是弹框弹出 i，但是由于 js 的执行机制，先同步再异步，把所有同步的 for 循环执行结束后，i 变成 4 了，那么每个弹框的内容都是 4.为了解决这个问题，可以使用闭包，让i驻留在内存中，这样闭包 onclick函数就能访问外面函数的变量，从而达到目的
			如果是一下代码，每一个 li 点击后都会打印 4
			var lis = document.getElementsByTagName('li');
      for(var i=0;i<lis.length;i++){
          lis[i].onclick = function(){
            alert(i);
          }
       
			闭包的形式：
			var lis = document.getElementsByTagName('li');
      for(var i=0;i<lis.length;i++){
        (function(i){
          lis[i].onclick = function(){
            alert(i);
          }
        })(i)
      }

3. 闭包的缺点
	3.1 变量会驻留在内存中，造成内存损耗问题。
				解决：把闭包的函数清空，设置为null
  3.2 内存泄漏【ie】 ==> 可说可不说，如果说一定要提到ie
```

### 作用域

```
1. 全局作用域
	最外层函数外面定义的变量拥有全局作用域
	所有未定义直接复制的变量 是全局变量
	所有 window 对象的属性拥有全局作用域
	全局作用域有很大弊端，过多的全局变量会污染全局命名空间，容易引起命名冲突
2. 函数作用域
	在函数内部声明的变量，只在函数内部生效
	内层的函数可以访问外层函数的变量，外层不能访问内层
3.块级作用域
	使用 ES6新增的 let、const、可以声明块级作用域变量，块级作用域就是一个{}包括的代码片段
	let 和 const 声明的变量不会有变量提升，也不可以重复声明
	在循环中适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部
```

### 作用域链

```
在当前作用域中查找所需的变量，如果当前作用域没有这个变量，就去父级作用域查找，直到访问到 window 对象就被终止，这一层层的关系就是作用域链
```

### var、let、const区别

```
var、let、const 共同点都是可以声明变量的

区别一：变量提升
	var 具有变量提升的机制
	let和const没有变量提升的机制
区别二：声明多个变量
	var 可以多次声明同一个变量
	let和const不可以多次声明同一个变量
区别三：作用域
	var声明的变量没有自身作用域
	let和const声明的变量有自身的作用域，就是一对{}包含的代码片段，也叫块级作用域
区别四：变量常量
	var、let声明变量的
	const声明常量
	var和let声明的变量可以再次赋值，但是const不可以再次赋值了。
	
	为什么const 的值不可以修改？
	const 保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本数据类型（字符串、数值、布尔值）来说，其值就是保存在变量指向的那个内存地址，因此等同于常量。
	但对于引用的数据类型，变量指向数据的内存地址，里面保存的是一个指针，const 只能保证这个指针是固定不变的，至于指针指向的数据结构是不是可变的，就完全不能控制了
	所以 const 声明的是常量，如果是基本类型不可以改变值，如果是引用数据类型，不可以直接赋值一个新的引用类型，但可以改变数据结构里面的值
	
	
区别五：全局添加属性
	var 声明的变量会作为全局对象 window 的属性，let 和 const则不会
	
区别六：初始值
let 和 var 可以不设置初始值，但 const 必须设置初始值

```

### let const作用域考题

考题一：let和const没有变量提升性

```
console.log( str );//undefined
var str = '你好';

console.log( num );//报错
let num = 10;
```

考题二：

```
function demo(){
	var n = 2;
	if( true ){
		var n = 1;
	}
	console.log( n );//1
}
demo();


function demo(){
	let n = 2;
	if( true ){
		let n = 1;
	}
	console.log( n );//2
}
demo();
```

考题三：可以修改

```
const obj = {
	a:1
}
obj.a = 11111;
console.log( obj )//11111

const arr = ['a','b','c'];
arr[0]= 'aaaaa';
console.log( arr );///aaaaa,b,c
```

### var作用域考题2

```
1. 函数有单独的作用域
2. 作用域链：内部可以访问外部的变量，但是外部不能访问内部的变量。
	 注意：如果内部有，优先查找到内部，如果内部没有就查找外部的。
3. 注意声明变量是用var还是没有写（window.）没有写就是全局变量
4. 注意：js有变量提升的机制【变量悬挂声明】
5. 优先级：声明变量 > 声明普通函数 > 参数 > 变量提升
```

面试的时候怎么看：

```
1. 本层作用域有没有此变量【注意变量提升】
2. 注意：js除了函数外没有块级作用域
3. 普通声明函数是不看写函数的时候顺序
```

##### 考题一：

```
function c(){
	var b = 1;
	function a(){
		console.log( b );
		var b = 2;//变量提升了，但是没有赋值
		console.log( b );
	}
	a();
	console.log( b );
}
c();// undefined,2,1
```

##### 考题二：

```
var name = 'a';
(function(){
//变量提升未赋值  var name；
	if( typeof name == 'undefined' ){
		var name = 'b';
		console.log('111'+name);
	}else{
		console.log('222'+name);
	}
})()  // 111b
```

##### 考题三：

```
function fun( a ){
	var a = 10;
	function a(){}
	console.log( a );
}
fun( 100 );//10   声明变量>普通函数>参数>变量提升
```

### JS对象考题

JS对象注意点：

```
1. 对象是通过new操作符构建出来的，所以对象之间不相等(除了引用外)；
2. 对象注意：引用类型(共同一个地址)；
3. 对象的key都是字符串类型；
4. 对象如何找属性|方法；
	查找规则：先在对象本身找 ===> 构造函数this中找 ===>  构造函数原型中找 ===> 对象上一层原型查找
```

##### 考题一：

```
 [1,2,3] === [1,2,3]   //false
```

##### 考题二：

```
var obj1 = {
	a:'hellow'
}
var obj2 = obj1;
obj2.a = 'world';
console.log(obj1); 	//{a:world}
(function(){
	console.log(a); 	//undefined
	var a = 1;
})();
```

##### 考题三：

```
var a = {}
var b = {
	key:'a'
}
var c = {
	key:'c'
}

a[b] = '123';
a[c] = '456';

console.log( a[b] ); // 456
```

### JS作用域+this指向+原型的考题

注意：

1. 如果用构造函数生成对象，用了 new 关键字，构造函数的this 指向该对象
2. 对象中的方法的 this 指向对象
3. 普通函数的的 this 指向 window

##### 考题一：

```
function Foo(){
	getName = function(){console.log(1)} //注意是全局的window.getName 函数
	return this;
}

Foo.getName = function(){console.log(2)} //getName属于函数 Foo，不属于Foo 的对象
Foo.prototype.getName = function(){console.log(3)}
var getName = function(){console.log(4)}
function getName(){
	console.log(5)
}

Foo.getName();    //2
getName(); 		  //4   变量声明>函数声明
Foo().getName();  //1 先给全局的 getName 重新赋值， return this 的结果是 window，window.getName()是用 window 的 getName 方法
getName();		  //1 也是全局的
new Foo().getName();//3    new Foo（）创建对象，对象找属性找不到，就去原型对象找这个属性
```

##### 考题二：

```
var o = {
	a:10,
	b:{
		a:2,
		fn:function(){
			console.log( this.a ); // 2
			console.log( this );   //代表b对象 fn 是 b 对象的方法
		}
	}
}
o.b.fn();
```

##### 考题三：

```
window.name = 'ByteDance';
function A(){
	this.name = 123;
}
A.prototype.getA = function(){
	console.log( this );
	return this.name + 1;
}
let a = new A();//a是一个对象
let funcA = a.getA; // 没执行，返回的是函数体
funcA();  // funcA就是一个普通函数，window  ByteDance1
```

##### 考题四：

```
var length = 10;
function fn(){
	return this.length + 1;
}
var obj = {
	length:5,
	test1:function(){
		return fn();
	}
}
obj.test2 = fn; //把 fn 的函数体给 ovj.test2
// obj.test2 = function(){
//			return this.length + 1;
//}
console.log( obj.test1() ); 							//11
console.log( fn()===obj.test2() ); 				//false  fn()返回的是 11 obj.test2()返回的是 6
console.log( obj.test1() == obj.test2() ); //false
```

### slice是干嘛的、splice是否会改变原数组

```
1. slice是来截取的
	参数可以写slice(3)、开始的索引，到结尾
	slice(1,3)、开始的索引，结束的索引，结束取不到
	slice(-3)倒数几个
	返回的是一个新的数组
2. splice 功能有：插入、删除、替换
	arr2 = arr1.splice（1,2）删除开始的索引，删除几个
	返回：删除的元素
	该方法会改变原数组
	
	替换：arr1.splice（1,1，‘你好’）最后一个参数作为替换的值 ，中间如果为 0 的话则是插入
```

### JS数组去重

#### 方式一：new set

展开运算符和 Array.from() 都可以把伪数组转换成数组

```
var arr1 = [1,2,3,2,4,1];
function unique(arr){ 
	return [...new Set(arr)]
}
console.log(  unique(arr1) );
```

#### 方式二：indexOf 建一个新数组，新数组中如果找到元素则不 push

```
var arr2 = [1,2,3,2,4,1];
function unique( arr ){
	var brr = [];
	for( var i=0;i<arr.length;i++){
		if(  brr.indexOf(arr[i]) == -1 ){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr2) );
```

#### 方式三：sort

```
var arr3 = [1,2,3,2,4,1];
function unique( arr ){
	arr = arr.sort();
	var brr = [];
	for(var i=0;i<arr.length;i++){
		if( arr[i] !== arr[i-1]){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr3) );
```

### 找出多维数组中每个小数组的最大值

```
function fnArr(arr){
	var newArr = [];
	arr.forEach((item,index)=>{
		newArr.push( Math.max(...item)  )
	})
	return newArr;
}
console.log(fnArr([
	[4,5,1,3],
	[13,27,18,26],
	[32,35,37,39],
	[1000,1001,857,1]
]));
```

### sort背后原理是什么？

```
sort（）方法用于对数组元素进行排序，并返回数组，默认排序是根据字符 Unicode 码点
arr.sort(参数)则可以按照规定的顺序进行排序，参数是一个函数

V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。

之前的版本是：插入排序和快排，现在是冒泡

原理实现链接：https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js

***710行代码开始***
```

### find和filter的区别

```
区别一：返回的内容不同
	filter 返回是新数组
	find   返回找到的那一项内容
区别二：返回的时机 
	find ：匹配到第一个即返回
	filter ： 返回整体（每一个匹配到的都返回）
```

### some和every的区别

```
some  ==》 如果有一项匹配则返回true，如果都不匹配则返回 false
every ==》 全部匹配才会返回true，如果有一个不匹配则返回 false
```





### 给字符串新增方法实现功能

给字符串对象定义一个addPrefix函数，当传入一个字符串str时，它会返回新的带有指定前缀的字符串，例如：

console.log( 'world'.addPrefix('hello') )  控制台会输出helloworld

考察给字符串对象新增一个方法，要加载 String.prototype上.方法里面的 this 指向字符串对象

```
解答：
String.prototype.addPrefix = function(str){
	return str  + this;
}
console.log( 'world'.addPrefix('hello') )
```

### 找出字符串出现最多次数的字符以及次数

```
var str = 'aaabbbbbccddddddddddx';
var obj = {};
for(var i=0;i<str.length;i++){
	var char = str.charAt(i);
	if( obj[char] ){
		obj[char]++;
	}else{
		obj[char] = 1;
	}
}
console.log( obj );
//统计出来最大值
var max = 0;
for( var key in obj ){
	if( max < obj[key] ){
		max = obj[key];
	}
}
//拿最大值去对比
for( var key in obj ){
	if( obj[key] == max ){
		console.log('最多的字符是'+key);
		console.log('出现的次数是'+max);
	}
}
```

### new操作符具体做了什么

```
1. 创建了一个空的对象
2. 将空对象的原型，指向于构造函数的原型
3. 构造函数的 this 指向新对象，并把属性和方法给到新对象
4. 对构造函数有返回值做判断处理，如果返回值是基本类型则忽略，如果返回值是引用类型则使用 return 返回的内容

```

```
如何实现一个 new
function Fun( age,name ){
	this.age = age;
	this.name = name;
}
function create( fn , ...args ){
	//1. 创建了一个空的对象
	var obj = {}; //或者 var obj = Object.create({})
	//2. 将空对象的原型，指向于构造函数的原型
	Object.setPrototypeOf(obj,fn.prototype);// 相当于 obj.__proto__=fn.prototype
	//3. 构造函数的 this 指向新对象，并把属性和方法给到新对象
	var result = fn.apply(obj,args);//args就代表参数数组
	//4. 对构造函数有返回值的处理判断
	return result instanceof Object ? result : obj;
}
console.log( create(Fun,18,'张三')   )
```

### JS 创建对象的方式有哪些

```
1. 利用字面量 var obj = {}
缺点：对于创建大量相似对象的时候，会产生大量的重复代码
2. 利用 new Object（）
3. 利用构造函数来创建对象
var 对象名 = new 构造函数名（参数）
JS 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，就可以称作构造函数。new 构造函数 首先会创建一个空对象，让这个对象的原型指向构造函数的原型，然后将执行上下文中的 this 指向这个对象，执行整个函数，如果返回值不是引用类型的话，则返回这个对象。优点是所创建的对象和构造函数之间建立了联系，且多个具有相同属性和方法的对象可以通过一个构造函数去创建，实现代码复用
缺点：每个对象在方法时，都会开辟新的内存空间

4. 构造函数和原型混合的模式
prototype 包含了通过构造函数的所有实例都能共享的属性和方法 但是如果一个实例改变了 prototype 中的属性或方法，则所有的实例都生效
通过构造函数来初始化对象的公共属性，通过 prototype 来声明对象共有的不会变的方法

5. 类的方法创建对象  var 对象名=new 类名（参数）
```



### JS继承有哪些方式

##### 方式一：ES6 Class

```
class Parent{
	constructor(){
		this.age = 18;
	}
}

class Child extends Parent{
	constructor(){
		super();//调用父类的构造函数
		this.name = '张三';
	}
}
let o1 = new Child();
console.log( o1,o1.name,o1.age );
```

##### 方式二：原型链继承



```
function Parent(){
	this.age = 20;
}
function Child(){
	this.name = '张三'
}
Child.prototype = new Parent();
let o2 = new Child();
console.log( o2,o2.name,o2.age );
```

##### 方式三：借用构造函数继承

```
function Parent(){
	this.age = 22;
}
function Child(){
	this.name = '张三'
	Parent.call(this);//this是 Child 的实例
}
let o3 = new Child();
console.log( o3,o3.name,o3.age );
```

##### 方式四：组合式继承

```
function Parent(){
	this.age = 100;
}
function Child(){
	Parent.call(this);//再用 call
	this.name = '张三'
}
Child.prototype = new Parent();//先用一下原型链
let o4 = new Child();
console.log( o4,o4.name,o4.age );
```

### 对 this 的理解

```
this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，在实际开发中，this的指向可以通过以下四种方式来判断
1. 函数调用，当一个函数不是某个对象的方法的时候，直接作为函数来调用时，this 指向全局对象 window
2. 方法调用，如果一个函数作为一个对象的方法来调用时，this 指向这个对象
3. new 构造对象，如果一个函数用 new 调用时，函数执行前会创建一个对象，this 指向这个新创建的对象
4. call、apply、bind：这三个方法都可以改变函数的 this 指向。其中 apply 接收两个参数，第一个是 this 绑定的对象，第二个是参数数组。call 方法接收的参数第一个是绑定的 this 值，后面是其余传入函数执行的参数。这两个方法都会将函数立即执行。bind 方法的第一个参数是 this 绑定的对象，后面是其余传入函数执行的参数，但是 bind 方法不会立即执行。

这四种方法改变 this 的方式，使用 new 的优先级最高，然后是 apply、call、bind，然后方法调用，最后是函数调用
```



### 说一下call、apply、bind区别

#### 共同点：功能一致

```
可以改变函数体内的this指向

语法： 函数.call()、函数.apply()、函数.bind()
```

##### 区别：

```
1. call、apply可以立即执行。bind不会立即执行，因为bind返回的是一个函数需要加入()执行。
2. 参数不同：apply第二个参数是数组。call和bind有多个参数需要挨个写。
```

##### 场景：

```
1. 用apply的情况：求数组的最大值
var arr1 = [1,2,4,5,7,3,321];
console.log( Math.max.apply(null,arr1) )

2. 用bind的情况：异步任务改变 this 指向
var btn = document.getElementById('btn');
var h1s = document.getElementById('h1s');
btn.onclick = function(){
	console.log( this.id );//这里的 this 是 btn
}.bind(h1s)//将 this 改变为h1
```

### 深拷贝和浅拷贝

```
共同点：复制

1. 浅拷贝：只复制引用，而未复制真正的值。
var arr1 = ['a','b','c','d'];
var arr2 = arr1;//改一个都会收到影响

var obj1 = {a:1,b:2}
var obj2 = Object.assign(obj1);
浅拷贝的方式：数组直接用等号赋值，对象直接用等号赋值，Object.assign(obj2)，扩展运算符

2. 深拷贝：是复制真正的值 （不同引用）
var obj3 = {
	a:1,
	b:2
}
var obj4 = JSON.parse(JSON.stringify( obj3 ));

//递归的形式
function copyObj( obj ){
	if(  Array.isArray(obj)  ){
		var newObj = [];
	}else{
		var newObj = {};
	}
	for( var key in obj ){
		if( typeof obj[key] == 'object' ){
			newObj[key] = copyObj(obj[key]);
		}else{
			newObj[key] = obj[key];
		}
	}
	return newObj;
}
console.log(  copyObj(obj5)  );

深拷贝的方式：JSON.parse(JSON.stringfy(obj2))、自己写递归的形式
```

### localStorage、sessionStorage、cookie的区别

```
公共点：在客户端存放数据
区别：
1. 数据存放有效期
		sessionStorage : 仅在当前浏览器窗口关闭之前有效。【关闭浏览器就没了】
		localStorage   : 始终有效，窗口或者浏览器关闭也一直保存，所以叫持久化存储。
		cookie				 : 只在设置的cookie过期时间之前有效，即使窗口或者浏览器关闭也有效。
2. localStorage、sessionStorage不可以设置过期时间
	 cookie 有过期时间，可以设置过期（把时间调整到之前的时间，就过期了）
3. 存储大小的限制
	cookie存储量不能超过4k
	localStorage、sessionStorage不能超过5M
	****根据不同的浏览器存储的大小是不同的。
用法：
sessionStorage.setItem('key',123);
localStorage.setItem('key',456);
cookie只能在线上环境设置
```

### 将下列对象进行合并

方式一：Object.assign 浅拷贝的方式

```
const a = {a:1,b:4};
const b = {b:2,c:3};

let obj1 = Object.assign(a,b);//如果有相同属性，取后面的
console.log( obj1 );
```

方式二：...展开运算符 浅拷贝

```
let obj2 = {...a,...b};
console.log( obj2 );
```

方式三：自己封装方法

```
function extend( target,  source ){
	for(var key in source){
		target[key] = source[key];
	}
	return target;
}
console.log( extend(a,b) );
```

### 箭头函数和普通函数有什么区别？

```
1. this指向的问题
	箭头函数不会创建自己的 this，它只会捕获上层作用域的 this作为自己的 this，所以箭头函数中的this是在箭头函数定义时就决定的，而且不可修改的（call、		apply、bind）
2. 箭头函数不能new（不能当作构造函数）
3. 箭头函数没有prototype
4. 箭头函数没有arguments
	arguments对象中存储了传递的所有实参，是一个伪数组
5.写法上的区别：比普通函数更简洁
	如果只有一个参数，不用带括号
	如果函数体只有一句，可以省略大括号
```

### 什么是 DOM BOM

```
1. DOM 是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的接口，比如获取元素，改变元素的值或者属性，监听元素的事件，设置事件处理函数
2. BOM 是浏览器对象模型，它指的是把浏览器当做一个对象，这个对象主要定义了与浏览器进行交互的方法和接口。
BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个全局对象。这意味着网页中定义的任何变量、函数、对象，都作为全局对象的一个属性或方法存在。window 对象含有 location 对象，navigator 对象，screen 对象。并且 DOM 的根对象 document 也是 BOM 中 window 对象的子对象
```



## 		1.4 H5/C3面试题

### 如何关闭IOS键盘首字母自动大写

```
<input type="text" autocapitalize='off'>
```

### 怎么让Chrome支持小于12px 的文字？

```
Chrome默认字体大小是：16px
**每个浏览器默认字体大小可能都不一样

<style type="text/css">
div{
	font-size:10px;
}
div span{
	display: inline-block;
	-webkit-transform:scale(0.5);
}
</style>
```

### ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉

```
<style>
	a,button,input,textarea{
		-webkit-tap-highlight-color: rgba(0,0,0,0);
	}
</style>
```

### webkit表单输入框placeholder的颜色值能改变吗？

```
<style type="text/css">
	input::-webkit-input-placeholder{
		color:red;
	}
</style>
```

### 禁止ios长按时触发系统的菜单，禁止ios&android长按时下载图片

```
禁止ios 长按时触发系统的菜单，禁止ios&android长按时下载图片
html,body{
	touch-callout: none;
	-webkit-touch-callout: none;
	
	user-select:none;
	-webkit-user-select:none;
}
```

### 禁止ios和android用户选中文字

```
html,body{
	user-select:none;
	-webkit-user-select:none;
}
```

### 自适应

```
如果使用 rem 的话，让根的 font-size 发生变化就可以了
淘宝无限适配【移动端】：淘宝无限适配 + 布局单位使用rem

它的原理是把当前设备划分为10等份，自动设置html的font-size=屏幕可视区域的宽/10。并且不同设备下，比例还是一致的。源码里有个 window.onresize事件，事件触发的话就会重置 html 的 font-size
```

### 响应式

```
1. 是什么？
	响应式网站设计是一个网站可以兼容多个终端，而不是为每个终端做一个特定的版本
	比如在 pc 端我显示完整的导航栏，在手机端只显示两个标签
  基本原理是通过媒体查询检测不同设备的屏幕尺寸做处理。使用媒体查询的前提条件是，页面头部必须有 meta 声明的 viewport width=device-width
2. 语法结构
	@media only screen and (max-width: 1000px){
		ul li:last-child{
			display: none;
		}
	}

	only : 可以排除不支持媒体查询的浏览器
	screen ： 设备类型
	max-width | max-height
	min-width | min-height 
3. 响应式图片【性能优化】
	<picture>
		<source srcset="1.jpg" media='(min-width:1000px)'>
		<source srcset="2.jpg" media='(min-width:700px)'>
		<img srcset="3.jpg">
	</picture>
```

### 布局方案

自适应和响应式是两个东西
自适应是不同尺寸的屏幕显示比例是一样的，元素根据屏幕的大小变化做变化

响应式是不同终端显示不一样的内容

```
一、什么情况下采用响应式布局
	
	数据不是特别多，用户量不是特别大，纯展示类的项目适合响应式布局
	
	例如：公司的官网、专题页面
	
	特别追求性能的项目，不太适合响应式，因为如果添加了很多的响应式就会造成加载速度变慢。

二、pc + 移动端应该做什么样的布局方案
	注意：访问量还可以或者比较大，类似于淘宝网。
	
	pc是一套，会加入一点点响应式。
	移动端是一套，会使用自适应的布局方式。

三、pc的设计图

	ui：1980
	笔记本电脑：1280
	ui图的宽度和电脑的宽度不对应该怎么办？
		1. 把ui图进行等比缩放，缩放成和电脑一样的尺寸
		2. 换1980的电脑
		3. 用比例来还原设计稿，
		假设设计稿是750px；
假设我们把这个屏幕划分为15等份
每一份作为html字体大小，这里就是50px，1rem=50px；
那么在320px设备的时候，字体大小就是 320/15=21.33px;
750px的屏幕中有一个100*100px 的盒子，就应该写 2rem*2rem

```

# 第二章 面试题进阶篇

### 对 Promise 的理解

```
Promise 是异步编程的一种解决方法。Promise 是一个构造函数，接受一个函数作为参数，分别是 resolve 和 reject。返回一个 Promise 实例。 一个 Promise 实例有三种状态，分别是 pending 进行中，resolved 已完成（或者 fulfilled），rejected已失败。实例的状态只能由 pending 转变为 resolved 或者 rejected 状态，并且一旦改变就凝固了，无法再被改变。
状态的改变是通过 resolve（）和 reject（）这两个函数实现的，可以在异步操作结束后调用这两个函数来改变 Promise 实例的状态。它的原型上有定义了一个 then（）方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。
```

### Promise 解决了什么问题

```
在实际开发中可以碰到这样的需求，比如我使用 ajax 发一个请求，成功后拿到数据，把数据在传给 B 请求中，那么这样几个异步任务就不能分开写，需要将他们转成同步任务的形式，一个完成了才能执行下一个，一般会用到回调函数，但这种方法就会产生回调地狱。多个ajax 请求嵌套在一起，可读性差，耦合性强
Promise 出现之后，就可以用.then()连续调用的方法实现异步任务顺序执行，不需要将多层回调函数嵌套在一起
```

### Async 和 Await 的理解

```
它是为优化then 链式调用而存在的，async 用于申明一个函数是异步的，await 用于等待一个异步方法执行完毕，才能执行下一个异步方法
await在等什么？
等一个异步函数完成，才会去执行下一个异步函数
await也在等一个表达式，计算出结果
（1）如果它后面不是一个 Promise 对象，那 await表达式的运算结果就是它后面的东西
（2）如果它后面是一个 Promise 对象，会阻塞后面的代码，等着 Promise 对象 resolve，拿到 resolve 的值，作为 await 表达式的运算结果，就不用 then 来获得了
```

### Async/await对比promise的优势

```
1. 代码阅读起来更加简洁，Promise 虽然摆脱了回调地狱，但是 then 的链式调用也会带来额外的阅读负担
2. Promise 传递中间值非常麻烦，resolve（值）.then()传出来，而 async await 几乎是同步的写法，await 关键字直接能把 resolve 的值取到
3. 处理错误友好，async/await可以用成熟的 try/catch捕获错误，而 Promise 捕获错误也比较冗余
4. 调试友好，不能在.then中使用调试器的步进功能，因为调试器只能跟踪同步代码的每一步
```

### 对 AJAx 的理解，实现 ajax 请求

```javascript
是通过 js 的异步通信，从服务器获取数据，再更新到当前页面的对应部分，而不用重新刷新整个页面

创建 Ajax 请求的步骤：
1. 创建一个 XMLHttpRequest对象
2. 调用.open('请求方式'，'url 地址？携带参数')
3. 调用.send()发起 Ajax 请求
4. .onreadystatechange()监听 readyState 请求状态和 status 服务器响应状态

发起 get 请求
// 1. 创建 XHR 对象
var xhr = new XMLHttpRequest()
// 2. 调用 open 函数，指定 请求方式 与 URL地址
xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks')
// 3. 调用 send 函数，发起 Ajax 请求
xhr.send()
// 4. 监听 onreadystatechange 事件
xhr.onreadystatechange = function() {
    // 4.1 监听 xhr 对象的请求状态 readyState ；与服务器响应的状态 status
    if (xhr.readyState === 4 && xhr.status === 200) {
        // 4.2 打印服务器响应回来的数据
       var result = JSON.parse(xhr.responseText)
        console.log(result)
    }
}


发起 post 请求
  // 1. 创建 xhr 对象
        var xhr = new XMLHttpRequest()
            // 2. 调用 open 函数
        xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook')
            // 3. 设置 Content-Type 属性 
        xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded')//给参数解码
            // 4. 调用 send 函数
        xhr.send('bookname=水浒传&author=施耐庵&publisher=上海图书出版社')
            // 5. 监听事件
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log(xhr.responseText)
            }
        }
```



### axios 请求

```
axios({
     method: '请求类型',
     url: '请求的URL地址',
     data: { /* POST数据 */ },
     params: { /* GET参数 */ }
 })
.then(callback)
```



​					2.2 webpack面试题

​				面试题：webpack插件

​		2.3 Git面试题

​				面试题：git常用命令

​				面试题：解决冲突

​				面试题：GitFlow

第三章 面试题框架篇

​		3.1 Vue面试题

​				面试题：Vue2.x 生命周期有哪些？

​				面试题：第一次进入组件或者页面，会执行哪些生命周期？

​				面试题：谈谈你对keep-alive的了解

​				面试题：v-if和v-show区别

​				面试题：v-if和v-for优先级

​				面试题：ref是什么？

​				面试题：nextTick是什么？

​				面试题：路由导航守卫有哪些？

​				面试题：Vue中如何做样式穿透

​				面试题：scoped原理

​				面试题：Vuex是单向数据流还是双向数据流？

​				面试题：讲一下MVVM

​				面试题：双向绑定原理

​				面试题：什么是虚拟DOM

​				面试题：diff算法

​				面试题：Vue组件传值

​				面试题：介绍一下SPA以及SPA有什么缺点？

​				面试题：Vue双向绑定和单向绑定

​				面试题：props和data优先级谁高？

​				面试题：computed、methods、watch有什么区别？

​				面试题：Vuex

​		3.2 微信小程序面试题

​				面试题：如何自定义头部？

​				面试题：如何自定义底部？

​		3.3 uni-app面试题

​				面试题：生命周期

​				面试题：条件编译

第四章 面试题性能优化篇

​		4.1 加载优化

​		4.2 图片优化

​		4.3 渲染优化

​		4.4 首屏优化

​		4.5 vue优化

第五章 面试题兼容篇

​		5.1 页面样式兼容

​		5.2 框架兼容

第六章 面试题网络请求篇

​		6.1 跨域面试题

​		6.2 http和https

第七章 WEB安全篇

​		7.1 XSS攻击

​		7.2 SQL注入

​		7.3 接口安全

第八章 其他类面试题

​		8.1 token

​		8.2 SEO



### 手写篇

### intanceof

intanceof 用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置

```javascript
function myInstanceof (left,right) {
  //获取对象的原型
  let proto = Object.getPrototypeOf(left)
  //获取构造函数的 prototype
  let prototype = right.prototype
  //获取构造函数的 prototype 对象
  while（true）{
    //如果 proto 为空返回 flase
    if(!proto) return false;
    //如果对象的 proto 是构造函数的 prototype 返回 true
    if(proto === prototype ) return true;
    //如果构造函数的 prototype 不是 对象的 proto，则在对象原型的原型上找
    proto = Object.getPrototype(proto);
  }
}
```

### 实现 new

```javascript
function Fun( age,name ){
	this.age = age;
	this.name = name;
}
function create( fn , ...args ){
	//1. 创建了一个空的对象
	var obj = {}; //或者 var obj = Object.create({})
	//2. 将空对象的原型，指向于构造函数的原型
	Object.setPrototypeOf(obj,fn.prototype);// 相当于 obj.__proto__=fn.prototype
	//3. 构造函数的 this 指向新对象，并把属性和方法给到新对象
	var result = fn.apply(obj,args);//args就代表参数数组
	//4. 对构造函数有返回值的处理判断
	return result instanceof Object ? result : obj;
}
console.log( create(Fun,18,'张三')   )
```

